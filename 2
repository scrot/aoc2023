package day16

import (
	"bufio"
	"bytes"
	"fmt"
	"hash/fnv"
)

type V1 struct{}

func (V1) Solve(input []byte, part int) (int, error) {
	var (
		r = bytes.NewReader(input)
		s = bufio.NewScanner(r)
		g [][]tile
	)

	// parse input
	for s.Scan() {
		r := make([]tile, len(s.Text()))
		for i, b := range s.Bytes() {
			r[i] = tile{b, false}
		}
		g = append(g, r)
	}

	// trace beam
	var (
		visited = make(map[int]bool)
		b, bs   = beam{}, []beam{{loc{-1, 0}, DirRight}}
	)

	for i := 0; len(bs) > 0 && i < 10; {
		b, bs = bs[0], bs[1:]

		if _, ok := visited[b.hash()]; ok {
			continue
		}
		visited[b.hash()] = true

		bs = append(bs, b.step(&g)...)

		if b.pos.x >= 0 && g[b.pos.y][b.pos.x].sym != '.' {
			for _, r := range g {
				for _, t := range r {
					if t.energized {
						fmt.Printf("*")
					} else {
						fmt.Printf("%c", t.sym)
					}
				}
				fmt.Println()
			}
		}
		fmt.Println()
	}

	// print grid
	var count int
	for _, r := range g {
		for _, t := range r {
			if t.energized {
				fmt.Printf("*")
				count++
			} else {
				fmt.Printf("%c", t.sym)
			}
		}
		fmt.Println()
	}

	return count, nil
}

type tile struct {
	sym       byte
	energized bool
}

type loc struct {
	x, y int
}

var (
	DirUp    = loc{0, -1}
	DirDown  = loc{0, 1}
	DirLeft  = loc{-1, 0}
	DirRight = loc{1, 0}
)

type beam struct {
	pos, dir loc
}

func (p beam) hash() int {
	h := fnv.New32a()
	fmt.Fprintf(h, "%d%d%d%d", p.pos.x, p.pos.y, p.dir.x, p.dir.y)
	return int(h.Sum32())
}

func (b beam) step(g *[][]tile) []beam {
	if b.pos.x >= 0 {
		(*g)[b.pos.y][b.pos.x].energized = true
	}

	// out of bound
	xm, ym := len((*g)[0]), len((*g))
	n := loc{b.pos.x + b.dir.x, b.pos.y + b.dir.y}
	if n.x < 0 || n.x >= xm || n.y < 0 || n.y >= ym {
		return []beam{}
	}

	switch (*g)[n.y][n.x].sym {
	case '/':
		switch b.dir {
		case DirUp:
			return []beam{{n, DirRight}}
		case DirDown:
			return []beam{{n, DirLeft}}
		case DirLeft:
			return []beam{{n, DirDown}}
		case DirRight:
			return []beam{{n, DirUp}}
		}
	case '\\':
		switch b.dir {
		case DirUp:
			return []beam{{n, DirLeft}}
		case DirDown:
			return []beam{{n, DirRight}}
		case DirLeft:
			return []beam{{n, DirUp}}
		case DirRight:
			return []beam{{n, DirDown}}
		}
	case '|':
		switch b.dir {
		case DirLeft, DirRight:
			return []beam{
				{n, DirUp},
				{n, DirDown},
			}
		case DirUp, DirDown:
			return []beam{{n, b.dir}}
		}
	case '-':
		switch b.dir {
		case DirLeft, DirRight:
			return []beam{{n, b.dir}}
		case DirUp, DirDown:
			return []beam{
				{n, DirLeft},
				{n, DirRight},
			}
		}
	case '.':
		return []beam{{n, b.dir}}
	}

	return []beam{}
}
